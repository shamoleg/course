Программирование робота на выполнение определенных действий – сложный процесс. Входные переменные зачастую неизвестны, потому машине приходится на лету подстраиваться под окружающие условия. Стандартные модели управления роботами разрабатывались в виде конечных автоматов [FSM – Finite-State Machine], однако этот способ плохо подходит для создания сложных алгоритмов, поскольку по мере добавления новых элементов модели, её сложность начинает быстро увеличиваться.

Чтобы сгладить эти недостатки, стал использоваться подход, широко применяемый разработчиками видеоигр. Речь идет о деревьях поведения. В отличие от конечных автоматов, деревья имеют более формальную структуру, поэтому с их помощью проще программировать поведение машины.

Дерево поведения [BT – Behavior Tree] – это ориентированный ациклический граф, узлами которого являются возможные варианты поведения робота. «Ширина» дерева указывает на количество доступных действий, а «длина» его ветвей характеризует их сложность.

Узлы BT называют задачами или поведениями. Каждая задача может иметь четыре состояния:

«Успех», если задача выполнена успешно;
«Неудача», если условие не выполнено или задача, по какой-то причине, невыполнима;
«В работе», если задача запущена в работу и ожидает завершения
«Ошибка», если в программе возникает неизвестная ошибка.

Результат работы любого узла всегда передается родительскому узлу, расположенному на уровень выше. Дерево просматривается с самого верхнего узла – корня. От него производится поиск в глубину начиная с левой ветви дерева. Если у одного узла есть несколько подзадач, они исполняются слева направо.

Среди узлов выделяют следующие типы: действие (action), узел исполнения последовательности (sequence), параллельный узел (parallel), селектор (selector), условие (condition), инвертор (inverter).

Действие представляет собой запись переменных или какое-либо движение. Узлы последовательностей поочередно исполняют поведения каждого дочернего узла до тех пор, пока один из них не выдаст значение «Неудача», «В работе» или «Ошибка». Если этого не произошло, возвращает значение «Успех».

Узлы параллельных действий исполняют поведения дочерних узлов до тех пор, пока заданное количество из них не вернет статусы «Неудача» или «Успех».

Селекторы поочередно исполняют поведения каждого дочернего узла до тех пор, пока один из них не выдаст значение «Успех», «В работе» или «Ошибка». Если этого не произошло, возвращает значение «Неудача».

Условия содержат критерий, по которому определяется исход, и переменную. Например, условие «Есть ли в этой комнате человек?» перебирает все объекты в комнате и сравнивает их с переменной «Человек». Узлы инверсии выполняют функцию оператора NOT.


##  Конечный автомат
Конечный автомат (КА — математическая абстракция, модель дискретного устройства, имеющего один вход, один выход и в каждый момент времени находящегося в одном состоянии из множества возможных. Является частным случаем абстрактного дискретного автомата, число возможных внутренних состояний которого конечно.

При работе на вход КА поступают последовательно входные воздействия, а на выходе КА формирует выходные сигналы. Обычно под входными воздействиями принимают подачу на вход автомата символов одного алфавита, а на выход КА в процессе работы выдаёт символы в общем случае другого, возможно даже не пересекающегося со входным, алфавита.

- Детерминированным конечным автоматом (ДКА) называется такой автомат, в котором нет дуг с меткой ε (предложение, не содержащее ни одного символа), и из любого состояния по любому символу возможен переход не более, чем в одно состояние.
- Недетерминированный конечный автомат (НКА) является обобщением детерминированного. Недетерминированность автоматов может достигаться двумя способами: либо могут существовать переходы из состояния в состояние, вызываемые пустой цепочкой символов, то есть самопроизвольные переходы без внешних воздействий, либо из одного состояния КА может переходить в разные состояния под воздействием одного и того же символа.

В чем преимущество деревьев поведения над конечными автоматами? По мере увеличения числа состояний конечного автомата, его сложность резко возрастает. Число переходов в FSM с количеством состояний N равняется N*(N-1). Если взять N = 4, то получим 12 возможных переходов. Если добавим еще одно состояние, переходов станет 20, еще одно – 30.

